package day03

import util.readInput

/**
 * --- 第 3 天：诊断二进制 ---
 *
 * 潜艇一直在制造一些奇怪的嘎吱声，所以你让它生成一份诊断报告以防万一。
 *
 * 诊断报告（这便是你的谜题输入）由一系列的二进制数字组成，如果解码得当，可以告诉你许多关于潜艇状况的有用信息。第一个要检查的参数就是 **功耗(power consumption)**。
 *
 * 你需要使用诊断报告中的二进制数来生成两个新的二进制数（称为 **伽马速率（gamma rate）** 和 **宇普西隆速率（epsilon rate）**）。
 * 功耗则可以通过把这两个速率相乘得到。
 *
 * 伽马速率中的每一位，都可以通过查找诊断报告中的所有数字**其对应位的最常见位**来确定。比如，给出下面这个诊断报告：
 *
 * ```
 * 00100
 * 11110
 * 10110
 * 10111
 * 10101
 * 01111
 * 00111
 * 11100
 * 10000
 * 11001
 * 00010
 * 01010
 * ```
 *
 * 首先只考虑每个数字的第一位，总共有五个 0 比特和七个 1 比特（垂直看）。因为最常见的比特位是 1，所以，伽马速率的第一位就是 1。
 *
 * 诊断报告中最常见的第二位数字是 0，所以伽马速率中的第二位也就是 0。
 *
 * 报告中最常见第三、四、五位数字分别是 1，1，0，所以相对的，伽马速率中的最后三位就是 110。
 *
 * 所以，伽马速率的二进制数为 10110，即十进制中的 **22**。
 *
 * 宇普西隆速率也是以相似的方式进行计算；不过不再使用最常见的比特位，而是使用最少见的比特位。所以，宇普西隆速率是 01001，即十进制中的 **9**。
 * 将伽马速率 (22) 和宇普西隆速率 (9) 相乘，就产生了功耗数据，即 **198**。
 *
 * 第一个问题：使用诊断报告中的二进制数来计算伽马速率和宇普西隆速率，然后将它们相乘。**求出潜艇的功耗是多少？**（请确保你的答案是十进制的而不是二进制的。）
 *
 * --- 第二部分 ---
 *
 * 接下来，你应该验证 **生命维持能力（life support rating）**，这可以通过 **氧气生成器的评估分（oxygen generator rating）**
 * 与 **二氧化碳洗涤器的评估分（CO2 scrubber rating）** 相乘来确定。
 *
 * 氧气发生器和二氧化碳洗涤器的评分都可以在你的诊断报告中找到 —— 但找到它们是最棘手的部分。这两个值都是使用相似的过程来进行定位
 * （过程为不断的把值过滤掉，直到只剩下一个）。在搜索任一评分之前，从诊断报告中二进制数字的完整列表开始，只**考虑这些数字的第一个比特位**。然后：
 *
 * - 只保留符合 **位保留标准（bit criteria）** 的数字（取决于你正在查找的评分类型）。然后丢弃掉那些不符合保留标准的数字。）
 * - 如果你只剩下了一个数字，停止；这就是你正在搜索的评分了。
 * - 否则，重复这个过程，并向右考虑下一个位。
 *
 * **位保留标准** 具体取决于你想查找哪种评分类型：
 *
 * - 要查找**氧气生成器的评分**，在当前位的位置上，确定好 **最常见** 的值（0 或是 1），然后只保留在这个位置上出现了这个值的数字。如果 0 和 1 都一样多，
 *   那么在这个位置上其值为 **1** 的数字就予以保留。
 * - 要查找**二氧化碳洗涤器的评分**，在当前位的位置上，确定好 **最少见** 的值（0 或是 1），然后只保留在这个位置上出现了这个值的数字。如果 0 和 1 都一样多，
 *   那么在这个位置上其值为 **0** 的数字就予以保留。
 *
 * 比如说，使用上面提到的示例诊断报告来确定**氧气生成器的评估分**：
 *
 * - 先从这全部 12 个数字开始，只考虑每个数字的第一位。比特 1 (7个) 比比特 0 (5个) 更多，所以只保留第一位为 1 的 7 个数字：
 *   11110, 10110, 10111, 10101, 11100, 10000, 和 11001。
 * - 然后，在剩余 7 个数字中考虑第二位：比特 0 (4个) 比比特 1 (3个) 更多，所以只保留第二位为 0 的 4 个数字：10110, 10111, 10101, 和 10000。
 * - 在第三位，四个数字中有 3 个都是 1，所以保留这三个数字：10110, 10111, 和 10101。
 * - 在第四位，三个数字中有 2 个是 1，所以保留这两个数字：10110 和 10111。
 * - 在第五个位置，比特 0 和比特 1 的数量一样多（都为 1 个）。由于我们查找的是**氧气生成器的评分**，所以，保留这个位置上比特为 1 的数字：10111。
 * - 现在只剩下一个数字了，停止；**氧气生成器的评分**就是 10111，即十进制中的 **23**。
 *
 * 然后，使用上述相同示例诊断报告来确定**二氧化碳洗涤器的评估分**：
 *
 * - 先从这全部 12 个数字开始，只考虑每个数字的第一位。比特 0 (5个) 比比特 1 (7个) 更少，所以只保留第一位为 0 的 5 个数字：
 *   00100, 01111, 00111, 00010, and 01010。
 * - 然后，在剩余 5 个数字中考虑第二位：比特 1 (2个) 比比特 0 (3个) 更少，所以只保留第二位为 1 的 2 个数字：01111 和 01010。
 * - 在第三位，比特 0 和比特 1 的数量一样多（都为 1 个）。由于我们查找的是**二氧化碳洗涤器的评分**，所以，保留这个位置上比特为 0 的数字：01010。
 * - 现在只剩下一个数字了，停止；**二氧化碳洗涤器的评分**就是 01010，即十进制中的 **10**。
 *
 * 最后，为了找出生命维持能力，将氧气生成器的评估分 (23) 和二氧化碳洗涤器 (10) 的评估分相乘得到 **230**。
 *
 * 第二个问题：使用诊断报告中的二进制数来计算氧气生成器评分和二氧化碳洗涤器评分，然后将它们相乘。**求出潜艇的生命维持能力是多少？**（请确保你的答案是十进制的而不是二进制的。）
 */
fun main() {
    // 第一个问题
    fun part1(input: List<String>): Int {
        val bits = IntArray(input[0].length)
        input.forEach { binary ->
            binary.forEachIndexed { i, b ->
                if (b == '1') bits[i] += 1 else bits[i] -= 1
            }
        }
        bits.forEachIndexed { i, n ->
            if (n > 0) bits[i] = 1 else bits[i] = 0
        }
        val gammaRate = bits.joinToString("").toInt(2)
        val epsilonMask = (Int.MIN_VALUE shr (Int.SIZE_BITS - bits.size - 1)).inv()
        return gammaRate * (gammaRate.inv() and epsilonMask)
    }

    // 第二个问题
    fun part2(input: List<String>): Int {
        val oxygenGeneratorRating = filterCriteriaValue(0, true, input)
        val co2ScrubberRating = filterCriteriaValue(0, false, input)
        return oxygenGeneratorRating * co2ScrubberRating
    }

    val testInput = readInput("day03_test")
    check(part1(testInput) == 198)
    check(part2(testInput) == 230)

    val input = readInput("day03")
    check(part1(input) == 2743844)
    check(part2(input) == 6677951)
}

private tailrec fun filterCriteriaValue(pos: Int, most: Boolean, list: List<String>): Int {
    if (list.size == 1) return list.first().toInt(2)
    val commonBit = calcCommonBitAtPosition(pos, most, list).digitToChar()
    return filterCriteriaValue(pos + 1, most, list.filter { it[pos] == commonBit })
}

private fun calcCommonBitAtPosition(pos: Int, most: Boolean, list: List<String>) =
    list.fold(0) { acc, s ->
        if (s[pos] == '1') acc.inc() else acc.dec()
    }.let {
        if (it < 0) {
            if (most) 0 else 1
        } else {
            if (most) 1 else 0
        }
    }