package day01

import util.readInput

/**
 * --- 第 1 天：声呐扫描 ---
 *
 * 当你正在海洋上的行船中忙着自己的工作的时候，舷外的警报响起来了！！你迅速跑出去想看看是否能帮上什么忙。显然的，你被某个小精灵绊了一跤，
 * 并意外的把雪橇的钥匙甩到了大海里！
 *
 * 你进入了潜艇（你都不知道这是小精灵们正是为了应对这种情况而准备的）。它被圣诞彩灯覆盖着（当然啦因为马上就是圣诞了），它甚至还有一个实验天线，
 * 如果能够把天线的信号强度增益到足够高的程度，它应该就能够追踪到你的钥匙；还有一个小仪表盘，通过 0-50 颗[星星]来显示天线的信号强度。
 *
 * 你的直觉告诉你，为了能够挽救你的圣诞节，你需要在 12 月 25 日前获得全部的 50 颗星星。
 *
 * 星星的收集从解决谜题开始。在 Advent 的日历上每天都会出两个谜题；只有当你解决了第一个谜题的时候，第二个谜题才会解锁。每个谜题都会授予你[一颗星星]。
 * 祝你好运！
 *
 * 当潜艇潜入海洋表面的时候，潜艇会自动对附近的海床进行声呐扫描。在小屏幕上会显示声呐扫描的报告（这便是你的谜题输入）：每一行都是一次对海床深度的测量，
 * 并且扫描越来越远离潜艇。
 *
 * 比如说，假设你收到了下面这样的报告：
 *
 * ```
 * 199
 * 200
 * 208
 * 210
 * 200
 * 207
 * 240
 * 269
 * 260
 * 263
 * ```
 *
 * 这个报告表示从潜艇向外扫描，声呐扫到的深度为 199，200，208，210... 等等。
 *
 * 首先要做的工作就是弄清楚水深增加速度究竟有多快，这样你就知道你怎么处理 —— 毕竟你永远不知道钥匙是否被洋流、鱼或者什么之类的带到了更深的水域中。
 *
 * 为此，我们要**计算每次深度测量都比前一次测量深度增加这种情况发生的次数**。（第一次测量前面没有其他的测量）在上面的例子中，变化如下：
 *
 * ```
 * 199 (N/A - 没有更早的测量了)
 * 200 (**增加**)
 * 208 (**增加**)
 * 210 (**增加**)
 * 200 (减少)
 * 207 (**增加**)
 * 240 (**增加**)
 * 269 (**增加**)
 * 260 (减少)
 * 263 (**增加**)
 * ```
 *
 * 在上面的例子中，有 **7** 次测量是比前一次测量更大的。
 *
 * 第一个问题：有多少次测量是比前一次测量更大的？
 *
 * --- 第二部分 ---
 *
 * 每一个测量值都予以考虑并不像你预计的那样有用：数据中有太多的噪音了。
 *
 * 相反，想象有一个以**三次测量总和组成的滑动窗口**。再考虑上面的例子：
 *
 * ```
 * 199  A
 * 200  A B
 * 208  A B C
 * 210    B C D
 * 200  E   C D
 * 207  E F   D
 * 240  E F G
 * 269    F G H
 * 260      G H
 * 263        H
 * ```
 *
 * 首先比较第一个和第二三个滑动窗口。第一个窗口中的测量值标记为 A（199, 200, 208）；它们的总和为 199 + 200 + 208 = 607。第二个窗口标记
 * 为 B （200, 208, 210）；它的总和是 618。第二个窗口中测量值的总和大于第一个窗口的总和，所以这第一个比较**增加**了。
 *
 * 现在你的目标是计算**每次滑动窗口中测量值的总和，都比前一次滑动窗口中总和增加的次数**。先比较 A 和 B，然后比较 B 和 C，再是 C 和 D，以此类推。
 * 当剩下的测量值不足以形成一个新的由三个测量值组成的总和时就结束。
 *
 * 在上面的例子中，每三次测量组成的窗口总和如下：
 *
 * ```
 * A: 607 (N/A - 没有更早的总和了)
 * B: 618 (**增加**)
 * C: 618 (不变)
 * D: 617 (减少)
 * E: 647 (**增加**)
 * F: 716 (**增加**)
 * G: 769 (**增加**)
 * H: 792 (**增加**)
 * ```
 *
 * 在这个例子中，总共有 **5** 次总和大于前一次总和。
 *
 * 第二个问题：考虑由三次测量总和组成的滑动窗口。有多少总和是比前一次总和更大的？
 */
fun main() {
    // 第一个问题
    fun part1(input: List<String>): Int =
        input.asSequence()
            .map(String::toInt)
            .windowed(2, 1) {
                it[1] compareTo it[0]
            }.count { it == 1 }

    // 第二个问题
    fun part2(input: List<String>): Int = input.asSequence()
        .map(String::toInt)
        .windowed(3, 1, transform = List<Int>::sum)
        .windowed(2, 1) {
            it[1] compareTo it[0]
        }.count { it == 1 }

    val testInput = readInput("day01_test")
    check(part1(testInput) == 7)
    check(part2(testInput) == 5)

    val input = readInput("day01")
    println(part1(input))
    println(part2(input))
}