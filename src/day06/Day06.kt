package day06

import util.readInputOneLine
import java.util.*

/**
 * --- 第 6 天：灯笼鱼 ---
 *
 * 海床愈发陡峭。或许雪橇的钥匙被带到了这里？
 *
 * 一大群发光的 [灯笼鱼](https://en.wikipedia.org/wiki/Lanternfish) 游了过去。它们必须快速繁殖才能达到这么大的数量 —— 或许是**指数级**的速度？
 * 你应该建模它们的生长速度来确定。
 *
 * 尽管你对这群特定的灯笼鱼一无所知，但你对它们的属性做了一些猜测。可以确定的说，每条灯笼鱼每 **7** 天就能生出一条新的灯笼鱼。
 *
 * 但是，这个过程在每条灯笼鱼身上并不都是同步的 —— 一条灯笼鱼可能只剩下 2 天就会生出另一条灯笼鱼，而另一条可能还差 4 天才会生。所以，
 * 你可以把每条鱼建模成一个代表**还有多少天它就会生出一条新灯笼鱼**的数字。
 *
 * 不止如此，你还认为一条**新的**灯笼鱼还需要稍微更长一点时间它才能够生出更多灯笼鱼：因此它的第一轮周期得 2 天后才开始。
 *
 * 所以，假设你有一个内部定时器值为 3 的灯笼鱼：
 *
 * - 一天后，它的内部定时器将变成 2。
 * - 又一天，它的内部定时器将变成 1。
 * - 又一天，它的内部定时器将变成 0。
 * - 又一天，它的内部定时器重设为 6，并且生出了一条**新的**灯笼鱼，其内部定时器为 8。
 * - 又一天，第一条灯笼鱼的内部定时器为 5，并且第二条灯笼鱼的内部定时器为 7。
 *
 * 灯笼鱼生出一条新鱼时会重设它的定时器为 6 **而不是 7**（因为 0 被包含在合法的定时器值之中了）。新生的灯笼鱼则从定时器值 8 开始，并直到
 * 下一天才开始倒数计时。
 *
 * 在认识到你正尝试去做什么的时候，潜艇自动生成了一个包含附近几百个灯笼鱼年龄的列表(这便是你的谜题输入)。比如说，假设你收到了下面这个列表：
 *
 * ```
 * 3,4,3,1,2
 * ```
 *
 * 这个列表表示第一条鱼的内部定时器为 3，第二条鱼的内部定时器为 4，然后以此类推直到第五条鱼，它的内部定时器值为 2。在几天之内模拟这些鱼会产生如下结果：
 *
 * ```
 * 初始状态：3,4,3,1,2
 * 1 天后：  2,3,2,0,1
 * 2 天后：  1,2,1,6,0,8
 * 3 天后：  0,1,0,5,6,7,8
 * 4 天后：  6,0,6,4,5,6,7,8,8
 * 5 天后：  5,6,5,3,4,5,6,7,7,8
 * 6 天后：  4,5,4,2,3,4,5,6,6,7
 * 7 天后：  3,4,3,1,2,3,4,5,5,6
 * 8 天后：  2,3,2,0,1,2,3,4,4,5
 * 9 天后：  1,2,1,6,0,1,2,3,3,4,8
 * 10 天后： 0,1,0,5,6,0,1,2,2,3,7,8
 * 11 天后： 6,0,6,4,5,6,0,1,1,2,6,7,8,8,8
 * 12 天后： 5,6,5,3,4,5,6,0,0,1,5,6,7,7,7,8,8
 * 13 天后： 4,5,4,2,3,4,5,6,6,0,4,5,6,6,6,7,7,8,8
 * 14 天后： 3,4,3,1,2,3,4,5,5,6,3,4,5,5,5,6,6,7,7,8
 * 15 天后： 2,3,2,0,1,2,3,4,4,5,2,3,4,4,4,5,5,6,6,7
 * 16 天后： 1,2,1,6,0,1,2,3,3,4,1,2,3,3,3,4,4,5,5,6,8
 * 17 天后： 0,1,0,5,6,0,1,2,2,3,0,1,2,2,2,3,3,4,4,5,7,8
 * 18 天后： 6,0,6,4,5,6,0,1,1,2,6,0,1,1,1,2,2,3,3,4,6,7,8,8,8,8
 * ```
 *
 * 每一天，当 0 变成 6 的时候都会增加一个新的 8 到列表中，同时如果其他的数在当天开始的时候就已经在列表中，则每个数字都减少 1。
 *
 * 在上面这个例子中，在 18 天后，里面总计有 26 条鱼。在 80 天之后，里面会总计有 **5934** 条鱼。
 *
 * 第一个问题：找到一种模拟灯笼鱼的方法。**在 80 天之后有多少条灯笼鱼？**
 *
 * --- 第二部分 ---
 *
 * 假设灯笼鱼永远生存，有无限的食物和空间。它们会占领整个海洋吗？
 *
 * 同样的例子，在 256 天后，总共会有 **26984457539** 条灯笼鱼！
 *
 * 第二个问题：**在 256 天之后有多少条灯笼鱼？**
 */
fun main() {
    // 第一个问题
    fun part1(input: String): Int {
        val fishes = input.split(",").map { it.trim().toInt() }.toCollection(LinkedList())
        (1..80).forEach { _ ->
            val iterator = fishes.listIterator()
            while (iterator.hasNext()) {
                val fish = iterator.next()
                if (fish - 1 < 0) {
                    iterator.set(6)
                    iterator.add(8)
                } else {
                    iterator.set(fish - 1)
                }
            }
        }
        return fishes.size
    }

    // 第二个问题
    fun part2(input: String): Long {
        TODO()
    }

    val testInput = readInputOneLine("day06_test")
    check(part1(testInput) == 5934)
//    check(part2(testInput) == 26984457539L)

    val input = readInputOneLine("day06")
    check(part1(input) == 396210)
//    check(part2(input) == )
}