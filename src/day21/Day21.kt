package day21

import util.readInput

/**
 * --- 第 21 天：狄拉克骰子 (Dirac Dice) ---
 *
 * 在你慢慢下降到海底觉得无事可做时，你潜艇的电脑向你挑战了一个叫做 **狄拉克骰子 (Dirac Dice)** 的好游戏。
 *
 * 这个游戏由一个 [骰子 (die)](https://en.wikipedia.org/wiki/Dice), 两个 [棋子 (pawns)](https://en.wikipedia.org/wiki/Glossary_of_board_games#piece),
 * 和一个含有十个从 1 到 10 顺时针方向标记好空间的环形轨道组成。每名玩家从 **哪个空间开始 (starting space)** 是随机选择的（这便是你的谜题输入）。由玩家 1 先移动棋子。
 *
 * 玩家们交替移动。在每个玩家的回合中，玩家首先要投 **三次** 骰子，并把投出的结果加和。然后，玩家将他们的棋子沿着轨道 **向前** 移动若干次（即，
 * 在空间上顺时针移动，以便让值不断增加，并在 10 之后又从 1 开始）。所以，如果某个玩家从空间 `7` 开始，然后投出了 `2`, `2` 和 `1` 结果，它就需要移动棋子 5 次，
 * 经过空间 `8`, `9`, `10` 和 `1`, 并最终停在 `2` 的上面。
 *
 * 每名玩家移动之后，都需要将他们的棋子所停留的空间上标记的值增加到他们的 **得分 (score)** 中。玩家的分数都从 0 开始。所以，如果第一个玩家从空间 7 开始，
 * 并且三次骰子的总和为 5，他最终将会停在空间 2 上，并加 2 到他的得分中（他的总分此时就是 2）。任何玩家率先达到 **至少 1000** 分的时候游戏就立刻结束。
 *
 * 因为第一个游戏是练习赛，潜艇打开了一个标签上写着 **确定性骰子** 的小隔板，并滚出了一个 100 面的骰子。这个骰子总是第一次掷出 1，然后是 2，再然后是 3，
 * 以此类推直到 100，在此之后又从 1 开始如此往复。就先使用这个骰子开始游玩。
 *
 * 比如，给定下面这个开始位置：
 *
 * ```
 * Player 1 starting position: 4
 * Player 2 starting position: 8
 * ```
 *
 * 下面显示了这个游戏会如何进行：
 *
 * - 玩家 1 掷出了 `1+2+3` 并移动棋子到空间 `10`, 此时他的总分是 `10`.
 * - 玩家 2 掷出了 `4+5+6` 并移动棋子到空间 `3`, 此时他的总分是 `3`.
 * - 玩家 1 掷出了 `7+8+9` 并移动棋子到空间 `4`, 此时他的总分是 `14`.
 * - 玩家 2 掷出了 `10+11+12` 并移动棋子到空间 `6`, 此时他的总分是 `9`.
 * - 玩家 1 掷出了 `13+14+15` 并移动棋子到空间 `6`, 此时他的总分是 `20`.
 * - 玩家 2 掷出了 `16+17+18` 并移动棋子到空间 `7`, 此时他的总分是 `16`.
 * - 玩家 1 掷出了 `19+20+21` 并移动棋子到空间 `6`, 此时他的总分是 `26`.
 * - 玩家 2 掷出了 `22+23+24` 并移动棋子到空间 `6`, 此时他的总分是 `22`.
 *
 * ...在很多回合后...
 *
 * - 玩家 2 掷出了 `82+83+84` 并移动棋子到空间 `6`, 此时他的总分是 `742`.
 * - 玩家 1 掷出了 `85+86+87` 并移动棋子到空间 `4`, 此时他的总分是 `990`.
 * - 玩家 2 掷出了 `88+89+90` 并移动棋子到空间 `3`, 此时他的总分是 `745`.
 * - 玩家 1 掷出了 `91+92+93` 并移动棋子到空间 `10`, 此时他最终分来到 `1000`.
 *
 * 因为玩家 1 已经得到了至少 1000 分，玩家 1 胜出并且游戏结束。在这个时候，失败者则获得了 745 分，并且骰子已经合计掷出了 993 次；745 * 993 = **739785**。
 *
 * 第一个问题：用这个确定性 100 面骰子来玩这个练习赛。在任一玩家胜出的时候，**如果你将失败者的得分，乘以在整局游戏中骰子掷出的总次数，你会得到多少？**
 *
 * --- 第二部分 ---
 *
 * 现在你已经热身完毕，是时候来玩真的了。
 *
 * 第二个隔板打开了，这次标签上写着 **狄拉克骰子**。从隔板里面掉出了一个三面的骰子。
 *
 * 正在你研究这个骰子的时候，你感到有一点奇怪。隔板中的小册子说这是一个 **量子骰子 (quantum die)**: 当你掷出它的时候，宇宙 **分裂出了多个拷贝 (splits into multiple copies)** ，
 * 每一份拷贝都是这个骰子可能的结果。在这种情况下，掷出骰子总会将宇宙分裂出 **三份拷贝**: 一份中骰子的结果是 1，另一份中骰子的结果是 2，最后一份骰子中的结果则是 3。
 *
 * 游戏和之前玩法一样，但为了防止事情变得过于失控，现在当任何一个玩家得分到达至少 **21** 分的时候游戏就会结束。
 *
 * 使用上面例子中相同的起始位置，玩家 1 在 **444356092776315** 个宇宙中胜出，而 玩家 2 只在 341960390180808 个宇宙中胜出了。
 *
 * 第二个问题：使用给你的起始位置，确定每一种可能的结果。**找出那位在更多的宇宙中胜出的玩家；该玩家究竟在多少个宇宙中都胜出了？**
 */
fun main() {
    // 第一个问题
    fun part1(input: List<String>): Int {
        val dice = DeterministicDice()
        val p1 = Player(input[0].substringAfterLast(" ").toInt(), dice)
        p1.pos = p1.pos - 1
        val p2 = Player(input[1].substringAfterLast(" ").toInt(), dice)
        p2.pos = p2.pos - 1
        var p1Score = 0
        var p2Score = 0
        var diceTimes = 0
        while (true) {
            p1Score += p1.action()
            diceTimes += 3
            if (p1Score >= 1000) break
            p2Score += p2.action()
            diceTimes += 3
            if (p2Score >= 1000) break
        }
        return if (p1Score >= 1000) p2Score * diceTimes else p1Score * diceTimes
    }

    // 第二个问题
    fun part2(input: List<String>): Long {
        TODO()
    }

    val testInput = readInput("day21_test")
    check(part1(testInput) == 739785)
    check(part2(testInput) == 444356092776315)

    val input = readInput("day21")
    check(part1(input) == 908595)
//    check(part2(input) == )
}

private data class Player(
    var pos: Int,
    val dice: Dice
) {
    fun action(): Int {
        repeat(3) {
            pos += dice.roll()
            pos %= 10
        }
        return pos + 1
    }
}

private interface Dice {
    fun roll(): Int
}

private data class DeterministicDice(
    var num: Int = 1
) : Dice {
    override fun roll(): Int = if (num % 101 == 0) {
        num = 1; num++
    } else num++
}