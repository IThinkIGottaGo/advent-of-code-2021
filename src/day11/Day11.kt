package day11

import util.readInput

/**
 * --- 第 11 天：小飞象章鱼 ---
 *
 * 你进入了一个巨大的洞穴，里面全是罕见的会发光的 [小飞象章鱼](https://www.youtube.com/watch?v=eih-VSaS2g0) ！它们似乎并不喜欢你潜艇上的圣诞灯光，
 * 所以你现在先将它们关掉。
 *
 * 有 100 只章鱼它们整齐的排成 10 x 10 的方格。每只章鱼都随着时间的推移缓慢的获得 **能量(energy)** ，并且当它能量充满时，它会明亮的 **闪光(flashes)** 片刻。
 * 因此即使你的灯光关闭了，或许你也能够在不打扰章鱼的情况下导航通过洞穴，如果你可以预测闪光什么时候会发生的话。
 *
 * 每只章鱼都有一个**能量等级(energy level)** —— 你的潜艇可以远程测量每只章鱼的能量等级（你的谜题输入）。比如说：
 *
 * ```
 * 5483143223
 * 2745854711
 * 5264556173
 * 6141336146
 * 6357385478
 * 4167524645
 * 2176841721
 * 6882881134
 * 4846848554
 * 5283751526
 * ```
 *
 * 每只章鱼的能量等级都在 0 到 9 之间。在这里，最左上方的章鱼能量等级为 5，最右下方的能量等级则为 6，以此类推。
 *
 * 你可以通过 **多个步骤(steps)** 来建模能量等级和光的闪烁。在单次步骤中，按照如下发生：
 *
 * - 首先，每只章鱼的能量等级加 1。
 * - 然后，任何能量等级大于 9 的章鱼就会 **闪光** 。这会使得其邻近的所有章鱼的能量等级也加上 1，包括那些对角相邻的章鱼。如果这又使得某个章鱼的能量等级大于了 9，
 * 那么它 **也会闪光** 。只要有新的章鱼使得它们的能量等级大于了 9，这个过程就会持续。（章鱼闪光 **每步骤至多只能一次**。）
 * - 最后，任何在该步骤中闪过光的章鱼它的能量等级重设为 0，因为它用尽了自己的能量来发光。
 *
 * 这样即使某个章鱼在步骤开始时候能量不多，但相邻发出的闪光也可能会让它在该步骤中引发它的发光。考虑下面在这种情况下中间能量为 1 的章鱼：
 *
 * 在任何步骤开始前：（为节省空间，省略部分原网站中的逐步展示；另外出现 `0` 即代表该章鱼在该步发光）
 *
 * ```
 * 11111
 * 19991
 * 19191
 * 19991
 * 11111
 * ```
 *
 * 经过第 1 步：
 *
 * ```
 * 34543
 * 40004
 * 50005
 * 40004
 * 34543
 * ```
 *
 * 经过第 2 步：
 *
 * ```
 * 45654
 * 51115
 * 61116
 * 51115
 * 45654
 * ```
 *
 * 在给定步骤中当某个章鱼发光的时候就会 **高亮加粗(highlighted)** 显示。
 *
 * 下面是上述过程在更大的例子中的展示：（为节省空间，省略部分原网站中的逐步展示；另外出现 `0` 即代表该章鱼在该步发光）
 *
 * 在任何步骤开始前：
 *
 * ```
 * 5483143223
 * 2745854711
 * 5264556173
 * 6141336146
 * 6357385478
 * 4167524645
 * 2176841721
 * 6882881134
 * 4846848554
 * 5283751526
 * ```
 *
 * 经过第 1 步：
 *
 * ```
 * 6594254334
 * 3856965822
 * 6375667284
 * 7252447257
 * 7468496589
 * 5278635756
 * 3287952832
 * 7993992245
 * 5957959665
 * 6394862637
 * ```
 *
 * 经过第 2 步：
 *
 * ```
 * 8807476555
 * 5089087054
 * 8597889608
 * 8485769600
 * 8700908800
 * 6600088989
 * 6800005943
 * 0000007456
 * 9000000876
 * 8700006848
 * ```
 *
 * 经过第 3 步：
 *
 * ```
 * 0050900866
 * 8500800575
 * 9900000039
 * 9700000041
 * 9935080063
 * 7712300000
 * 7911250009
 * 2211130000
 * 0421125000
 * 0021119000
 * ```
 *
 * 经过第 4 步：
 *
 * ```
 * 2263031977
 * 0923031697
 * 0032221150
 * 0041111163
 * 0076191174
 * 0053411122
 * 0042361120
 * 5532241122
 * 1532247211
 * 1132230211
 * ```
 *
 * 省略中间...
 *
 * 经过第 8 步：
 *
 * ```
 * 7818477333
 * 5488477444
 * 5697666949
 * 4608766830
 * 4734946730
 * 4740097688
 * 6900007564
 * 0000009666
 * 8000004755
 * 6800007755
 * ```
 *
 * 经过第 9 步：
 *
 * ```
 * 9060000644
 * 7800000976
 * 6900000080
 * 5840000082
 * 5858000093
 * 6962400000
 * 8021250009
 * 2221130009
 * 9111128097
 * 7911119976
 * ```
 *
 * 经过第 10 步：
 *
 * ```
 * 0481112976
 * 0031112009
 * 0041112504
 * 0081111406
 * 0099111306
 * 0093511233
 * 0442361130
 * 5532252350
 * 0532250600
 * 0032240000
 * ```
 *
 * 经过 10 步之后，已经总计发生了 204 次闪光了。现在快进，下面是一样的配置，只不过每次变成了 10 步：
 *
 * 经过第 20 步：
 *
 * ```
 * 3936556452
 * 5686556806
 * 4496555690
 * 4448655580
 * 4456865570
 * 5680086577
 * 7000009896
 * 0000000344
 * 6000000364
 * 4600009543
 * ```
 *
 * 经过第 30 步：
 *
 * ```
 * 0643334118
 * 4253334611
 * 3374333458
 * 2225333337
 * 2229333338
 * 2276733333
 * 2754574565
 * 5544458511
 * 9444447111
 * 7944446119
 * ```
 *
 * 省略中间...
 *
 * 经过第 90 步：
 *
 * ```
 * 7433333522
 * 2643333522
 * 2264333458
 * 2226433337
 * 2222433338
 * 2287833333
 * 2854573333
 * 4854458333
 * 3387779333
 * 3333333333
 * ```
 *
 * 经过第 100 步：
 *
 * ```
 * 0397666866
 * 0749766918
 * 0053976933
 * 0004297822
 * 0004229892
 * 0053222877
 * 0532222966
 * 9322228966
 * 7922286866
 * 6789998766
 * ```
 *
 * 在经过 100 步之后，已经总共发生了 **1656** 次闪光了。
 *
 * 第一个问题：根据在你洞穴中给出的小飞象章鱼们的初始能量等级，模拟 100 步。**在进行了 100 步之后总共闪光了多少次？**
 *
 * --- 第二部分 ---
 *
 * 看起来单独的发光并不足以能够导航。但是，你可以有一个更好的选择：让闪光变成就像是 **同步的(synchronizing)**!
 *
 * 在上面的例子中，第一次所有的章鱼都同步发光是发生在经过第 **195** 步：
 *
 * 经过第 194 步：
 *
 * ```
 * 6988888888
 * 9988888888
 * 8888888888
 * 8888888888
 * 8888888888
 * 8888888888
 * 8888888888
 * 8888888888
 * 8888888888
 * 8888888888
 * ```
 *
 * 经过第 195 步：
 *
 * ```
 * 0000000000
 * 0000000000
 * 0000000000
 * 0000000000
 * 0000000000
 * 0000000000
 * 0000000000
 * 0000000000
 * 0000000000
 * 0000000000
 * ```
 *
 * 如果你能够精确计算出所有章鱼都同步发光的瞬间，你就应该能够导航离开洞穴了。**那么，第一次所有章鱼都同时发光的那一步是第多少步？**
 */
fun main() {
    // 第一个问题
    fun part1(input: List<String>): Int {
        val octopus = input.flatMap { it.map(Octopus::toOctopus) }
        var sum = 0
        (1..100).forEach {
            octopus.indices.forEach {
                octopus.execEnergyGains(it)
            }
            sum += octopus.calcFlashTimesAndReset()
        }
        return sum
    }

    // 第二个问题
    fun part2(input: List<String>): Int {
        val octopus = input.flatMap { it.map(Octopus::toOctopus) }
        var path = 1
        while (true) {
            octopus.indices.forEach {
                octopus.execEnergyGains(it)
            }
            if (octopus.calcFlashTimesAndReset() == 100) {
                break
            }
            ++path
        }
        return path
    }

    val testInput = readInput("day11_test")
    check(part1(testInput) == 1656)
    check(part2(testInput) == 195)

    val input = readInput("day11")
    check(part1(input) == 1741)
    check(part2(input) == 440)
}

private fun List<Octopus>.execEnergyGains(i: Int) {
    val o = this[i]
    if (o.flashed) return
    o.energy += 1
    if (o.flashed) {
        if ((i + 1) % 10 != 0) execEnergyGains(i + 1)
        if (i % 10 != 0) execEnergyGains(i - 1)
        if (i - 10 >= 0) execEnergyGains(i - 10)
        if (i + 10 < size) execEnergyGains(i + 10)
        if ((i + 1) % 10 != 0 && i - 9 > 0) execEnergyGains(i - 9)
        if (i % 10 != 0 && i - 11 >= 0) execEnergyGains(i - 11)
        if ((i + 1) % 10 != 0 && i + 11 < size) execEnergyGains(i + 11)
        if (i % 10 != 0 && i + 9 < size) execEnergyGains(i + 9)
    }
}

private fun List<Octopus>.calcFlashTimesAndReset(): Int {
    var sum = 0
    for (o in this) {
        if (o.flashed) {
            ++sum
            o.energy = 0
        }
    }
    return sum
}

private data class Octopus(
    var energy: Int
) {
    val flashed: Boolean
        get() = energy > 9

    companion object {
        fun toOctopus(c: Char) = Octopus(c.digitToInt())
    }
}